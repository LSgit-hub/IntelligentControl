# 智能控制助手 (Intelligent Control Assistant) 项目规划

## 项目概述

创建一个Windows系统命令行应用，通过与AI对话让API或本地模型协助用户操控计算机。该应用将允许用户通过自然语言与AI交互，让AI帮助完成各种计算机操作任务。

## 核心功能

### 1. 工具系统

将各种编程语言解释器包装成工具，供AI使用：

```python
# tools/interpreter_tools.py
import subprocess
import json
import os
import tempfile
from typing import Dict, Any, List

class InterpreterTools:
    def __init__(self):
        self.interpreters = {
            'python': 'python',
            'node': 'node',
            'powershell': 'powershell',
            'bash': 'bash',
            'ruby': 'ruby',
            'perl': 'perl',
            'lua': 'lua'
        }

    def execute_code(self, language: str, code: str) -> Dict[str, Any]:
        """
        执行指定语言的代码并返回结果

        参数:
            language: 编程语言名称
            code: 要执行的代码

        返回:
            包含执行结果的字典
        """
        if language not in self.interpreters:
            return {"error": f"不支持的编程语言: {language}"}

        try:
            # 创建临时文件
            with tempfile.NamedTemporaryFile(mode='w', suffix=f'.{language}', delete=False) as temp_file:
                temp_file.write(code)
                temp_file_path = temp_file.name

            # 根据不同语言选择执行方式
            if language == 'powershell':
                cmd = f'{self.interpreters[language]} -ExecutionPolicy Bypass -File "{temp_file_path}"'
            elif language == 'bash':
                cmd = f'bash "{temp_file_path}"'
            else:
                cmd = f'{self.interpreters[language]} "{temp_file_path}"'

            # 执行代码
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30  # 30秒超时
            )

            # 清理临时文件
            os.unlink(temp_file_path)

            return {
                "success": True,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "return_code": result.returncode
            }
        except subprocess.TimeoutExpired:
            return {"error": "代码执行超时"}
        except Exception as e:
            return {"error": str(e)}

    def get_supported_languages(self) -> List[str]:
        """获取支持的编程语言列表"""
        return list(self.interpreters.keys())
```

### 2. 系统操作工具

```python
# tools/system_tools.py
import os
import subprocess
import shutil
import winreg
import ctypes
import json
import sys
from typing import Dict, Any, List

class SystemTools:
    def __init__(self):
        pass

    def execute_command(self, command: str) -> Dict[str, Any]:
        """
        执行系统命令

        参数:
            command: 要执行的命令

        返回:
            包含执行结果的字典
        """
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30
            )
            return {
                "success": True,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "return_code": result.returncode
            }
        except subprocess.TimeoutExpired:
            return {"error": "命令执行超时"}
        except Exception as e:
            return {"error": str(e)}

    def list_files(self, path: str = ".") -> Dict[str, Any]:
        """
        列出指定目录中的文件

        参数:
            path: 目录路径

        返回:
            包含文件列表的字典
        """
        try:
            files = os.listdir(path)
            file_info = []
            for file in files:
                full_path = os.path.join(path, file)
                file_info.append({
                    "name": file,
                    "path": full_path,
                    "is_dir": os.path.isdir(full_path),
                    "size": os.path.getsize(full_path) if not os.path.isdir(full_path) else 0
                })
            return {"success": True, "files": file_info}
        except Exception as e:
            return {"error": str(e)}

    def create_directory(self, path: str) -> Dict[str, Any]:
        """
        创建目录

        参数:
            path: 目录路径

        返回:
            操作结果
        """
        try:
            os.makedirs(path, exist_ok=True)
            return {"success": True, "message": f"目录已创建: {path}"}
        except Exception as e:
            return {"error": str(e)}

    def create_file(self, path: str, content: str = "") -> Dict[str, Any]:
        """
        创建文件

        参数:
            path: 文件路径
            content: 文件内容

        返回:
            操作结果
        """
        try:
            with open(path, 'w', encoding='utf-8') as f:
                f.write(content)
            return {"success": True, "message": f"文件已创建: {path}"}
        except Exception as e:
            return {"error": str(e)}

    def read_file(self, path: str) -> Dict[str, Any]:
        """
        读取文件内容

        参数:
            path: 文件路径

        返回:
            包含文件内容的字典
        """
        try:
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
            return {"success": True, "content": content}
        except Exception as e:
            return {"error": str(e)}

    def write_file(self, path: str, content: str) -> Dict[str, Any]:
        """
        写入文件内容

        参数:
            path: 文件路径
            content: 要写入的内容

        返回:
            操作结果
        """
        try:
            with open(path, 'w', encoding='utf-8') as f:
                f.write(content)
            return {"success": True, "message": f"内容已写入: {path}"}
        except Exception as e:
            return {"error": str(e)}

    def delete_file(self, path: str) -> Dict[str, Any]:
        """
        删除文件或目录

        参数:
            path: 文件或目录路径

        返回:
            操作结果
        """
        try:
            if os.path.isdir(path):
                shutil.rmtree(path)
                return {"success": True, "message": f"目录已删除: {path}"}
            else:
                os.remove(path)
                return {"success": True, "message": f"文件已删除: {path}"}
        except Exception as e:
            return {"error": str(e)}

    def get_system_info(self) -> Dict[str, Any]:
        """
        获取系统信息

        返回:
            包含系统信息的字典
        """
        try:
            info = {
                "os": os.name,
                "platform": sys.platform,
                "user": os.getenv('USERNAME'),
                "computer": os.getenv('COMPUTERNAME'),
                "home": os.path.expanduser('~')
            }
            return {"success": True, "info": info}
        except Exception as e:
            return {"error": str(e)}

    def get_registry_value(self, key_path: str, value_name: str) -> Dict[str, Any]:
        """
        获取注册表值

        参数:
            key_path: 注册表路径
            value_name: 值名称

        返回:
            包含注册表值的字典
        """
        try:
            # 将路径转换为Windows注册表格式
            if key_path.startswith("HKEY_"):
                key_path = key_path.replace("/", "\\")

            # 分割键路径和值名称
            if "\\" in key_path:
                key_part = key_path
            else:
                key_part = key_path

            # 打开注册表项
            key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE if key_part.startswith("HKEY_LOCAL_MACHINE") 
                                else winreg.HKEY_CURRENT_USER, key_part)

            # 获取值
            value, _ = winreg.QueryValueEx(key, value_name)
            winreg.CloseKey(key)

            return {"success": True, "value": value}
        except Exception as e:
            return {"error": str(e)}

    def run_as_admin(self, command: str) -> Dict[str, Any]:
        """
        以管理员权限运行命令

        参数:
            command: 要运行的命令

        返回:
            执行结果
        """
        try:
            # 检查是否具有管理员权限
            if not ctypes.windll.shell32.IsUserAnAdmin():
                return {"error": "需要管理员权限"}

            # 以管理员身份运行命令
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30
            )

            return {
                "success": True,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "return_code": result.returncode
            }
        except subprocess.TimeoutExpired:
            return {"error": "命令执行超时"}
        except Exception as e:
            return {"error": str(e)}
```

## 其他功能

### 1. AI接口管理

```python
# ai_interface/ai_manager.py
import openai
import requests
import json
from typing import Dict, Any, List, Optional

class AIManager:
    def __init__(self):
        self.providers = {
            'openai': OpenAIProvider(),
            'lmstudio': LMStudioProvider(),
            'ollama': OllamaProvider()
        }
        self.current_provider = None
        self.current_model = None

    def list_providers(self) -> List[str]:
        """列出所有可用的AI提供商"""
        return list(self.providers.keys())

    def add_provider(self, provider_name: str, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        添加AI提供商

        参数:
            provider_name: 提供商名称
            config: 配置信息

        返回:
            操作结果
        """
        try:
            if provider_name.lower() == 'openai':
                self.providers['openai'] = OpenAIProvider(config)
            elif provider_name.lower() == 'lmstudio':
                self.providers['lmstudio'] = LMStudioProvider(config)
            elif provider_name.lower() == 'ollama':
                self.providers['ollama'] = OllamaProvider(config)
            else:
                return {"error": f"不支持的提供商: {provider_name}"}

            return {"success": True, "message": f"已添加提供商: {provider_name}"}
        except Exception as e:
            return {"error": str(e)}

    def remove_provider(self, provider_name: str) -> Dict[str, Any]:
        """
        移除AI提供商

        参数:
            provider_name: 提供商名称

        返回:
            操作结果
        """
        try:
            if provider_name.lower() in self.providers:
                del self.providers[provider_name.lower()]
                if self.current_provider == provider_name.lower():
                    self.current_provider = None
                    self.current_model = None
                return {"success": True, "message": f"已移除提供商: {provider_name}"}
            else:
                return {"error": f"提供商不存在: {provider_name}"}
        except Exception as e:
            return {"error": str(e)}

    def set_current_provider(self, provider_name: str, model: str = None) -> Dict[str, Any]:
        """
        设置当前使用的AI提供商和模型

        参数:
            provider_name: 提供商名称
            model: 模型名称

        返回:
            操作结果
        """
        try:
            if provider_name.lower() not in self.providers:
                return {"error": f"提供商不存在: {provider_name}"}

            self.current_provider = provider_name.lower()
            if model:
                self.current_model = model

            return {"success": True, "message": f"已设置提供商: {provider_name}"}
        except Exception as e:
            return {"error": str(e)}

    def list_models(self, provider_name: str = None) -> Dict[str, Any]:
        """
        列出提供商的可用模型

        参数:
            provider_name: 提供商名称，如果为None则使用当前提供商

        返回:
            包含模型列表的字典
        """
        try:
            provider = self.providers.get(provider_name.lower() if provider_name else self.current_provider)
            if not provider:
                return {"error": "未找到指定的提供商"}

            return {"success": True, "models": provider.list_models()}
        except Exception as e:
            return {"error": str(e)}

    def chat(self, messages: List[Dict[str, str]], model: str = None) -> Dict[str, Any]:
        """
        与AI聊天

        参数:
            messages: 消息列表
            model: 模型名称，如果为None则使用当前模型

        返回:
            AI的回复
        """
        try:
            if not self.current_provider:
                return {"error": "未设置AI提供商"}

            provider = self.providers[self.current_provider]
            return provider.chat(messages, model or self.current_model)
        except Exception as e:
            return {"error": str(e)}


class OpenAIProvider:
    def __init__(self, config: Dict[str, Any] = None):
        self.api_key = config.get('api_key') if config else None
        self.api_base = config.get('api_base') if config else None
        self.models = []
        self.update_models()

    def update_models(self):
        """更新可用模型列表"""
        try:
            if not self.api_key:
                self.models = ["gpt-3.5-turbo", "gpt-4"]
                return

            headers = {
                "Authorization": f"Bearer {self.api_key}"
            }

            url = f"{self.api_base or 'https://api.openai.com'}/v1/models"
            response = requests.get(url, headers=headers)

            if response.status_code == 200:
                data = response.json()
                self.models = [model['id'] for model in data.get('data', [])]
            else:
                self.models = ["gpt-3.5-turbo", "gpt-4"]
        except Exception:
            self.models = ["gpt-3.5-turbo", "gpt-4"]

    def list_models(self) -> List[str]:
        """列出可用模型"""
        return self.models

    def chat(self, messages: List[Dict[str, str]], model: str = "gpt-3.5-turbo") -> Dict[str, Any]:
        """与OpenAI聊天"""
        try:
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.api_key}"
            }

            url = f"{self.api_base or 'https://api.openai.com'}/v1/chat/completions"

            data = {
                "model": model,
                "messages": messages
            }

            response = requests.post(url, headers=headers, json=data)

            if response.status_code == 200:
                result = response.json()
                return {
                    "success": True,
                    "content": result['choices'][0]['message']['content'],
                    "usage": result.get('usage', {})
                }
            else:
                return {
                    "success": False,
                    "error": response.text
                }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }


class LMStudioProvider:
    def __init__(self, config: Dict[str, Any] = None):
        self.api_base = config.get('api_base') if config else "http://localhost:1234"
        self.models = []
        self.update_models()

    def update_models(self):
        """更新可用模型列表"""
        try:
            url = f"{self.api_base}/v1/models"
            response = requests.get(url)

            if response.status_code == 200:
                data = response.json()
                self.models = [model['id'] for model in data.get('data', [])]
            else:
                self.models = ["default"]
        except Exception:
            self.models = ["default"]

    def list_models(self) -> List[str]:
        """列出可用模型"""
        return self.models

    def chat(self, messages: List[Dict[str, str]], model: str = None) -> Dict[str, Any]:
        """与LM Studio聊天"""
        try:
            url = f"{self.api_base}/v1/chat/completions"

            data = {
                "model": model or "default",
                "messages": messages,
                "temperature": 0.7,
            }

            response = requests.post(url, json=data)

            if response.status_code == 200:
                result = response.json()
                return {
                    "success": True,
                    "content": result['choices'][0]['message']['content'],
                    "usage": result.get('usage', {})
                }
            else:
                return {
                    "success": False,
                    "error": response.text
                }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }


class OllamaProvider:
    def __init__(self, config: Dict[str, Any] = None):
        self.api_base = config.get('api_base') if config else "http://localhost:11434"
        self.models = []
        self.update_models()

    def update_models(self):
        """更新可用模型列表"""
        try:
            url = f"{self.api_base}/api/tags"
            response = requests.get(url)

            if response.status_code == 200:
                data = response.json()
                self.models = [model['name'] for model in data.get('models', [])]
            else:
                self.models = ["llama2"]
        except Exception:
            self.models = ["llama2"]

    def list_models(self) -> List[str]:
        """列出可用模型"""
        return self.models

    def chat(self, messages: List[Dict[str, str]], model: str = "llama2") -> Dict[str, Any]:
        """与Ollama聊天"""
        try:
            url = f"{self.api_base}/api/chat"

            data = {
                "model": model,
                "messages": messages,
                "stream": False
            }

            response = requests.post(url, json=data)

            if response.status_code == 200:
                result = response.json()
                return {
                    "success": True,
                    "content": result['message']['content'],
                    "usage": result.get('usage', {})
                }
            else:
                return {
                    "success": False,
                    "error": response.text
                }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
```

### 2. MCP (Model Context Protocol) 管理器

```python
# mcp/mcp_manager.py
import json
import os
import requests
from typing import Dict, Any, List, Optional

class MCPManager:
    def __init__(self):
        self.servers = {}
        self.active_servers = []
        self.load_servers()

    def load_servers(self):
        """从配置文件加载MCP服务器"""
        config_path = os.path.join(os.path.expanduser('~'), '.ica', 'mcp_servers.json')
        try:
            if os.path.exists(config_path):
                with open(config_path, 'r', encoding='utf-8') as f:
                    self.servers = json.load(f)
            else:
                self.servers = {}
        except Exception as e:
            print(f"加载MCP服务器配置失败: {e}")
            self.servers = {}

    def save_servers(self):
        """保存MCP服务器配置到文件"""
        config_dir = os.path.join(os.path.expanduser('~'), '.ica')
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)

        config_path = os.path.join(config_dir, 'mcp_servers.json')
        try:
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(self.servers, f, indent=2)
        except Exception as e:
            print(f"保存MCP服务器配置失败: {e}")

    def list_servers(self) -> List[Dict[str, Any]]:
        """列出所有MCP服务器"""
        return list(self.servers.values())

    def add_server(self, name: str, endpoint: str, description: str = "", config: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        添加MCP服务器

        参数:
            name: 服务器名称
            endpoint: 服务器端点
            description: 服务器描述
            config: 服务器配置

        返回:
            操作结果
        """
        try:
            if name in self.servers:
                return {"error": f"服务器名称已存在: {name}"}

            self.servers[name] = {
                "name": name,
                "endpoint": endpoint,
                "description": description,
                "config": config or {},
                "active": False
            }

            self.save_servers()
            return {"success": True, "message": f"已添加服务器: {name}"}
        except Exception as e:
            return {"error": str(e)}

    def remove_server(self, name: str) -> Dict[str, Any]:
        """
        移除MCP服务器

        参数:
            name: 服务器名称

        返回:
            操作结果
        """
        try:
            if name not in self.servers:
                return {"error": f"服务器不存在: {name}"}

            if name in self.active_servers:
                self.active_servers.remove(name)

            del self.servers[name]
            self.save_servers()
            return {"success": True, "message": f"已移除服务器: {name}"}
        except Exception as e:
            return {"error": str(e)}

    def activate_server(self, name: str) -> Dict[str, Any]:
        """
        激活MCP服务器

        参数:
            name: 服务器名称

        返回:
            操作结果
        """
        try:
            if name not in self.servers:
                return {"error": f"服务器不存在: {name}"}

            # 测试服务器连接
            endpoint = self.servers[name]["endpoint"]
            response = requests.get(f"{endpoint}/health", timeout=5)

            if response.status_code == 200:
                self.active_servers.append(name)
                self.servers[name]["active"] = True
                self.save_servers()
                return {"success": True, "message": f"已激活服务器: {name}"}
            else:
                return {"error": f"服务器连接失败: {response.text}"}
        except Exception as e:
            return {"error": str(e)}

    def deactivate_server(self, name: str) -> Dict[str, Any]:
        """
        停用MCP服务器

        参数:
            name: 服务器名称

        返回:
            操作结果
        """
        try:
            if name not in self.servers:
                return {"error": f"服务器不存在: {name}"}

            if name in self.active_servers:
                self.active_servers.remove(name)

            self.servers[name]["active"] = False
            self.save_servers()
            return {"success": True, "message": f"已停用服务器: {name}"}
        except Exception as e:
            return {"error": str(e)}

    def get_server_tools(self, name: str) -> Dict[str, Any]:
        """
        获取MCP服务器的工具列表

        参数:
            name: 服务器名称

        返回:
            工具列表
        """
        try:
            if name not in self.servers:
                return {"error": f"服务器不存在: {name}"}

            if name not in self.active_servers:
                return {"error": f"服务器未激活: {name}"}

            endpoint = self.servers[name]["endpoint"]
            response = requests.get(f"{endpoint}/tools", timeout=5)

            if response.status_code == 200:
                return {"success": True, "tools": response.json()}
            else:
                return {"error": f"获取工具列表失败: {response.text}"}
        except Exception as e:
            return {"error": str(e)}

    def call_server_tool(self, name: str, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """
        调用MCP服务器的工具

        参数:
            name: 服务器名称
            tool_name: 工具名称
            arguments: 工具参数

        返回:
            工具执行结果
        """
        try:
            if name not in self.servers:
                return {"error": f"服务器不存在: {name}"}

            if name not in self.active_servers:
                return {"error": f"服务器未激活: {name}"}

            endpoint = self.servers[name]["endpoint"]
            data = {
                "tool": tool_name,
                "arguments": arguments
            }

            response = requests.post(f"{endpoint}/call", json=data, timeout=30)

            if response.status_code == 200:
                return {"success": True, "result": response.json()}
            else:
                return {"error": f"工具调用失败: {response.text}"}
        except Exception as e:
            return {"error": str(e)}
```

### 3. 交互功能

```python
# interaction/command_interpreter.py
import re
import json
from typing import Dict, Any, List, Optional

class CommandInterpreter:
    def __init__(self, ai_manager, mcp_manager):
        self.ai_manager = ai_manager
        self.mcp_manager = mcp_manager
        self.commands = {
            'help': self.show_help,
            'ai': self.handle_ai_command,
            'mcp': self.handle_mcp_command,
            'exit': self.exit_app,
            'clear': self.clear_screen
        }

    def interpret(self, input_str: str) -> Dict[str, Any]:
        """
        解释用户输入并执行相应命令

        参数:
            input_str: 用户输入

        返回:
            执行结果
        """
        input_str = input_str.strip()

        # 如果是AI对话模式
        if not input_str.startswith('/'):
            return self.handle_ai_chat(input_str)

        # 解析命令
        command_parts = input_str[1:].split(' ', 1)
        command = command_parts[0].lower()

        if command not in self.commands:
            return {"error": f"未知命令: {command}. 输入 '/help' 查看可用命令"}

        # 执行命令
        if len(command_parts) > 1:
            return self.commands[command](command_parts[1])
        else:
            return self.commands[command]()

    def show_help(self, args: str = "") -> Dict[str, Any]:
        """显示帮助信息"""
        help_text = """
可用命令:
  /help                    - 显示此帮助信息
  /ai                      - AI相关命令
  /mcp                     - MCP服务器相关命令
  /exit                    - 退出应用
  /clear                   - 清空屏幕

AI命令:
  /ai list                 - 列出所有AI提供商
  /ai add <name> [config]  - 添加AI提供商 (config为JSON格式)
  /ai remove <name>        - 移除AI提供商
  /ai use <name> [model]   - 设置当前使用的AI提供商和模型
  /ai models [provider]   - 列出提供商的可用模型
  /ai chat                 - 进入AI对话模式

MCP命令:
  /mcp list               - 列出所有MCP服务器
  /mcp add <name> <endpoint> [desc] - 添加MCP服务器
  /mcp remove <name>      - 移除MCP服务器
  /mcp activate <name>    - 激活MCP服务器
  /mcp deactivate <name>  - 停用MCP服务器
  /mcp tools <name>       - 列出服务器的工具
  /mcp call <name> <tool> [args] - 调用服务器工具 (args为JSON格式)
        """
        return {"success": True, "content": help_text}

    def handle_ai_command(self, args: str) -> Dict[str, Any]:
        """处理AI相关命令"""
        command_parts = args.split(' ', 1)
        subcommand = command_parts[0].lower()

        if subcommand == 'list':
            providers = self.ai_manager.list_providers()
            return {"success": True, "providers": providers}

        elif subcommand == 'add':
            if len(command_parts) < 2:
                return {"error": "用法: /ai add <name> [config]"}

            name = command_parts[1]
            config_str = command_parts[2] if len(command_parts) > 2 else "{}"

            try:
                config = json.loads(config_str)
                result = self.ai_manager.add_provider(name, config)
                return result
            except json.JSONDecodeError:
                return {"error": "配置格式错误，应为有效的JSON"}

        elif subcommand == 'remove':
            if len(command_parts) < 2:
                return {"error": "用法: /ai remove <name>"}

            name = command_parts[1]
            return self.ai_manager.remove_provider(name)

        elif subcommand == 'use':
            if len(command_parts) < 2:
                return {"error": "用法: /ai use <name> [model]"}

            name = command_parts[1]
            model = command_parts[2] if len(command_parts) > 2 else None

            return self.ai_manager.set_current_provider(name, model)

        elif subcommand == 'models':
            provider = command_parts[1] if len(command_parts) > 1 else None
            return self.ai_manager.list_models(provider)

        elif subcommand == 'chat':
            return {"mode": "ai_chat"}

        else:
            return {"error": f"未知AI命令: {subcommand}. 输入 '/ai help' 查看可用命令"}

    def handle_mcp_command(self, args: str) -> Dict[str, Any]:
        """处理MCP相关命令"""
        command_parts = args.split(' ', 1)
        subcommand = command_parts[0].lower()

        if subcommand == 'list':
            servers = self.mcp_manager.list_servers()
            return {"success": True, "servers": servers}

        elif subcommand == 'add':
            if len(command_parts) < 3:
                return {"error": "用法: /mcp add <name> <endpoint> [desc]"}

            parts = command_parts[1].split(' ', 2)
            if len(parts) < 2:
                return {"error": "用法: /mcp add <name> <endpoint> [desc]"}

            name = parts[0]
            endpoint = parts[1]
            desc = parts[2] if len(parts) > 2 else ""

            return self.mcp_manager.add_server(name, endpoint, desc)

        elif subcommand == 'remove':
            if len(command_parts) < 2:
                return {"error": "用法: /mcp remove <name>"}

            name = command_parts[1]
            return self.mcp_manager.remove_server(name)

        elif subcommand == 'activate':
            if len(command_parts) < 2:
                return {"error": "用法: /mcp activate <name>"}

            name = command_parts[1]
            return self.mcp_manager.activate_server(name)

        elif subcommand == 'deactivate':
            if len(command_parts) < 2:
                return {"error": "用法: /mcp deactivate <name>"}

            name = command_parts[1]
            return self.mcp_manager.deactivate_server(name)

        elif subcommand == 'tools':
            if len(command_parts) < 2:
                return {"error": "用法: /mcp tools <name>"}

            name = command_parts[1]
            return self.mcp_manager.get_server_tools(name)

        elif subcommand == 'call':
            if len(command_parts) < 3:
                return {"error": "用法: /mcp call <name> <tool> [args]"}

            parts = command_parts[1].split(' ', 2)
            if len(parts) < 2:
                return {"error": "用法: /mcp call <name> <tool> [args]"}

            name = parts[0]
            tool = parts[1]
            args_str = parts[2] if len(parts) > 2 else "{}"

            try:
                args = json.loads(args_str)
                return self.mcp_manager.call_server_tool(name, tool, args)
            except json.JSONDecodeError:
                return {"error": "参数格式错误，应为有效的JSON"}

        else:
            return {"error": f"未知MCP命令: {subcommand}. 输入 '/mcp help' 查看可用命令"}

    def handle_ai_chat(self, message: str) -> Dict[str, Any]:
        """处理AI对话"""
        if not self.ai_manager.current_provider:
            return {"error": "未设置AI提供商，请使用 '/ai use <name>' 设置"}

        # 构建消息历史
        messages = [{"role": "user", "content": message}]

        # 调用AI
        result = self.ai_manager.chat(messages)

        if result.get("success"):
            return {"success": True, "content": result["content"]}
        else:
            return {"error": result.get("error", "AI对话失败")}

    def exit_app(self, args: str = "") -> Dict[str, Any]:
        """退出应用"""
        return {"exit": True}

    def clear_screen(self, args: str = "") -> Dict[str, Any]:
        """清空屏幕"""
        os.system('cls' if os.name == 'nt' else 'clear')
        return {"success": True}
```

## 主程序

```python
# main.py
import os
import sys
import json
import argparse
from ai_interface.ai_manager import AIManager
from mcp.mcp_manager import MCPManager
from interaction.command_interpreter import CommandInterpreter

def main():
    # 创建必要的目录
    config_dir = os.path.join(os.path.expanduser('~'), '.ica')
    if not os.path.exists(config_dir):
        os.makedirs(config_dir)

    # 初始化管理器
    ai_manager = AIManager()
    mcp_manager = MCPManager()
    command_interpreter = CommandInterpreter(ai_manager, mcp_manager)

    # 主循环
    print("智能控制助手 (Intelligent Control Assistant)")
    print("输入 '/help' 查看可用命令")
    print("-" * 50)

    while True:
        try:
            # 获取用户输入
            user_input = input("> ")

            # 解释并执行命令
            result = command_interpreter.interpret(user_input)

            # 处理特殊命令
            if result.get("exit"):
                print("再见！")
                break

            # 显示结果
            if "content" in result:
                print(result["content"])
            elif "error" in result:
                print(f"错误: {result['error']}")
            elif "success" in result and not result["success"]:
                print(f"操作失败: {result.get('error', '未知错误')}")
            elif result.get("mode") == "ai_chat":
                print("AI对话模式 (输入 '/exit' 退出)")
                print("-" * 20)

                # AI对话循环
                while True:
                    user_input = input("AI: ")

                    if user_input == "/exit":
                        break

                    # 构建消息历史
                    messages = [{"role": "user", "content": user_input}]

                    # 调用AI
                    ai_result = ai_manager.chat(messages)

                    if ai_result.get("success"):
                        print(f"AI: {ai_result['content']}")
                    else:
                        print(f"错误: {ai_result.get('error', 'AI对话失败')}")

                print("-" * 20)
                print("已退出AI对话模式")

        except KeyboardInterrupt:
            print("
再见！")
            break
        except Exception as e:
            print(f"发生错误: {e}")

if __name__ == "__main__":
    main()
```

## 项目结构

```
IntelligentControl/
│
├── README.md                # 项目说明文档
├── requirements.txt         # 项目依赖
├── main.py                 # 主程序入口
│
├── ai_interface/           # AI接口模块
│   ├── __init__.py
│   ├── ai_manager.py       # AI管理器
│   ├── openai_provider.py  # OpenAI提供商实现
│   ├── lmstudio_provider.py # LM Studio提供商实现
│   └── ollama_provider.py  # Ollama提供商实现
│
├── mcp/                    # MCP (Model Context Protocol) 模块
│   ├── __init__.py
│   └── mcp_manager.py      # MCP管理器
│
├── tools/                  # 工具模块
│   ├── __init__.py
│   ├── interpreter_tools.py # 解释器工具
│   └── system_tools.py     # 系统操作工具
│
└── interaction/            # 交互模块
    ├── __init__.py
    └── command_interpreter.py # 命令解释器
```

## 依赖项

创建 `requirements.txt` 文件：

```
openai>=1.0.0
requests>=2.28.0
```

## 安装和使用说明

### 安装步骤

1. 克隆或下载项目代码
2. 安装依赖: `pip install -r requirements.txt`
3. 运行程序: `python main.py`

### 使用说明

1. 启动程序后，输入 `/help` 查看可用命令
2. 添加AI提供商:
   ```
   /ai add openai {"api_key": "your-api-key"}
   ```
3. 设置当前AI提供商:
   ```
   /ai use openai
   ```
4. 进入AI对话模式:
   ```
   /ai chat
   ```
5. 添加MCP服务器:
   ```
   /mcp add myserver http://localhost:8080 "我的MCP服务器"
   ```
6. 激活MCP服务器:
   ```
   /mcp activate myserver
   ```
7. 列出服务器工具:
   ```
   /mcp tools myserver
   ```
8. 调用服务器工具:
   ```
   /mcp call myserver mytool {"param1": "value1"}
   ```

## 未来扩展

1. 添加更多AI提供商支持
2. 实现更复杂的工具系统
3. 添加用户配置和偏好设置
4. 实现插件系统
5. 添加日志记录功能
6. 实现多语言支持
7. 添加图形界面选项
